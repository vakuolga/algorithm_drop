// ID успешной посылки: 69383141

/*
-- ПРИНЦИП РАБОТЫ --
Ключ к решению задачи - построение ориентированного графа для карты железных дорог
по принципу направления дорог одного типа в одну сторону,
дорог второго типа - в противоположную и обнаружение цикла в таком графе.


С помщощью функции defineOptimal определяем истонность устверждения оптимальность карты железных дорог.
Для удобства определения уже посещенных городов (вершин) создаем отдельный "цветовой" массив, где будем
    помечать вершины тремя цветами:
    - белый - не посещенный город,
    - серый - уже посещенный, но не все его ребра обработаны,
    - черный - город уже посещен и все его ребра обработаны.

Таким образом, если в процессе обхода графа мы наткнемся на серый город, это означает, что в графе есть цикл.
Это означает, что существует пара городов, между которыми есть маршрут с разным типом дорог и
карта железных дорог в этом случае является не оптимальной.
    
Возьмем пример из трех городов.
    1 ---- B ----> 2 ---- B ----> 3
    |                             |
    1 ============ R ===========> 3
    
Из города 1 можно добраться в город 2 с помощью дороги типа В,
Из города 1 можно добраться в город 3 с помощью дороги типа R.
Из города 2 можно добраться в город 3 с помощью дороги типа В.
На примере из трех городов видно что в город 3 можно добраться двумя путями:
Из города 1 через город 2 по дорогам типа В;
Из города 1 напрямую по дороге типа R.

Образуется цикл, состоящий из двух дороги типа В (города 1 - 2 и 2 - 3) и дороги типа R (города 1 - 3).
Таким образом чтобы дать ответ на задачу оптимальна ли сеть железных дорог или нет необходимо построить граф и
определить имеются ли в нем циклы или нет.
При условии: по дорогам можно двигаться только от города с меньшим номером к городу с большим номером.

Если в построенном графе существует цикл, то карта железных дорог - оптимальна.
Карта железных дорог называется оптимальной, если не существует пары городов A и B такой,
что от A до B можно добраться как по дорогам типа R, так и по дорогам типа B.
Пусть в построенном графе существует цикл An, An+1, ... An+i, ... An. Следовательно, по построению,
существует пара Aj, Ak такая, что Ak < Aj (реверсивное ребро), следовательно, существует пара Aj, Ak городов
такая, что от Ak до Aj можно добраться как по дорогам типа B, так и по дорогам типа R => карта дорого не оптимальна
Противоречие.
    Ak ---- B ----> An ---- B ----> An+i ---- B ----> Aj
    |                                                  |
    Ak ====================== R ====================> Aj

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
O(V+E) - как в DFS со списками смежности.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
O(E*V) - список смежности, где E - количество вершин, V - количество рёбер.

*/
const _readline = require('readline');

const _reader = _readline.createInterface({
    input: process.stdin
});
let edgesCount = 0, counter = 0;
_reader.on('line', line => {
    counter += 1;
    if (counter == 1) {
        edgesCount = Number(line);
    } else {
        let edge = line.split('');
        for (let j = 0; j < edge.length; j++) {
            let type = edge[j];
            if (type == 'B') {
                addEdge(counter-2, counter-2+j+1);
            } else if (type == 'R') {
                addEdge(counter-2+j+1, counter-2);
            }
        }
    }
});
let adjacencyList = {};
// функция, которая добавляет ребра в граф
function addEdge(u, v) {
    // ребра u-->v
    adjacencyList[u] ? adjacencyList[u].push(v) : adjacencyList[u] = [v];
}
process.stdin.on('end', solve);

function defineOptimal(count) {
    const WHITE = 0, GRAY = 1, BLACK = 2;
    
    // рекурсивная функция для поиска ребра, начинающегося с u и направленного в другую сторону
    function DFS(list, startv, colors) {
        let adjList = list;
        let stack = [], res = true;
        stack.push(startv);
        while (stack.length > 0 && res == true) {
            let w = stack.pop();
            if (colors[w] == WHITE) {
                colors[w] = GRAY;
                stack.push(w);
                // проверяем все смежные с w вершины
                if (adjList[w]) {
                    for (let i = 0; i < adjList[w].length; i++) {
                        let v = adjList[w][i];
                        // если есть ребро к вершине, складываем в стек
                        if (colors[v] == WHITE) {
                            stack.push(v);
                        // если встречаем серую вершину - цикл
                        } else if (colors[v] == GRAY) {
                            return false
                        }
                    }
                }
            } else if (colors[w] == GRAY) {
                colors[w] = BLACK;
            }
        }
        return res
    }
    // возвращает false, если в графе есть цикл
    function isOptiomal(adjacencyList) {
        // изначально все вершины в графе белые
        let colors = Array(count);
        for (let i = 0; i < count; i++) {
            colors[i] = WHITE;
        }
        // проходим DFS начиная с каждой вершины
        for (let i = 0; i < count; i++) {
            if (colors[i] == WHITE) {
                if (DFS(adjacencyList, i, colors) == false) {
                    return false;
                }
            }
        }
        return true;
    }
    
    if (!isOptiomal(adjacencyList)) {
        return "NO"; // цикл найден
    } else {
        return "YES"; // цикл не найден
    }
}

function solve() {
    process.stdout.write(`${defineOptimal(edgesCount)}`);
}